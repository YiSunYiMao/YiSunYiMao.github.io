<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>排序方法合集 - 一榫一卯-YiSunYiMao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="一榫一卯-YiSunYiMao"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="一榫一卯-YiSunYiMao"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="数据结构、C语言、python"><meta property="og:type" content="blog"><meta property="og:title" content="排序方法合集"><meta property="og:url" content="http://example.com/2021/12/8/%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/"><meta property="og:site_name" content="一榫一卯-YiSunYiMao"><meta property="og:description" content="数据结构、C语言、python"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/day/day1/%E6%AF%94%E8%BE%83.png"><meta property="og:image" content="http://example.com/img/day/day1/%E5%86%92%E6%B3%A11.png"><meta property="og:image" content="http://example.com/img/day/day1/%E5%86%92%E6%B3%A12.gif"><meta property="og:image" content="http://example.com/img/day/day1/%E9%80%89%E6%8B%A92.gif"><meta property="og:image" content="http://example.com/img/day/day1/%E9%80%89%E6%8B%A91.png"><meta property="og:image" content="http://example.com/img/day/day1/%E6%8F%92%E5%85%A52.gif"><meta property="og:image" content="http://example.com/img/day/day1/%E6%8F%92%E5%85%A51.png"><meta property="og:image" content="http://example.com/img/day/day1/%E6%8A%98%E5%8D%8A1.png"><meta property="og:image" content="http://example.com/img/day/day1/%E6%8A%98%E5%8D%8A2.png"><meta property="og:image" content="http://example.com/img/day/day1/%E5%B8%8C%E5%B0%941.png"><meta property="og:image" content="http://example.com/img/day/day1/%E5%B8%8C%E5%B0%942.png"><meta property="og:image" content="http://example.com/img/day/day1/%E5%B8%8C%E5%B0%943.png"><meta property="og:image" content="http://example.com/img/day/day1/%E5%A0%861.png"><meta property="og:image" content="http://example.com/img/day/day1/%E5%A0%862.png"><meta property="og:image" content="http://example.com/img/day/day1/%E5%A0%863.png"><meta property="og:image" content="http://example.com/img/day/day1/%E5%BD%92%E5%B9%B62.png"><meta property="og:image" content="http://example.com/img/day/day1/%E5%BD%92%E5%B9%B61.gif"><meta property="og:image" content="http://example.com/img/day/day1/%E5%BD%92%E5%B9%B63.png"><meta property="og:image" content="http://example.com/img/day/day1/%E5%BF%AB%E9%80%9F1.png"><meta property="og:image" content="http://example.com/img/day/day1/%E5%BF%AB%E9%80%9F2.gif"><meta property="og:image" content="http://example.com/img/day/day1/%E5%BF%AB%E9%80%9F3.gif"><meta property="article:published_time" content="2021-12-08T07:30:40.000Z"><meta property="article:modified_time" content="2022-07-23T14:12:02.892Z"><meta property="article:author" content="YiSunYiMao"><meta property="article:tag" content="python"><meta property="article:tag" content="C"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/day/day1/%E6%AF%94%E8%BE%83.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/12/8/%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/"},"headline":"排序方法合集","image":["http://example.com/img/day/day1/%E6%AF%94%E8%BE%83.png","http://example.com/img/day/day1/%E5%86%92%E6%B3%A11.png","http://example.com/img/day/day1/%E5%86%92%E6%B3%A12.gif","http://example.com/img/day/day1/%E9%80%89%E6%8B%A92.gif","http://example.com/img/day/day1/%E9%80%89%E6%8B%A91.png","http://example.com/img/day/day1/%E6%8F%92%E5%85%A52.gif","http://example.com/img/day/day1/%E6%8F%92%E5%85%A51.png","http://example.com/img/day/day1/%E6%8A%98%E5%8D%8A1.png","http://example.com/img/day/day1/%E6%8A%98%E5%8D%8A2.png","http://example.com/img/day/day1/%E5%B8%8C%E5%B0%941.png","http://example.com/img/day/day1/%E5%B8%8C%E5%B0%942.png","http://example.com/img/day/day1/%E5%B8%8C%E5%B0%943.png","http://example.com/img/day/day1/%E5%A0%861.png","http://example.com/img/day/day1/%E5%A0%862.png","http://example.com/img/day/day1/%E5%A0%863.png","http://example.com/img/day/day1/%E5%BD%92%E5%B9%B62.png","http://example.com/img/day/day1/%E5%BD%92%E5%B9%B61.gif","http://example.com/img/day/day1/%E5%BD%92%E5%B9%B63.png","http://example.com/img/day/day1/%E5%BF%AB%E9%80%9F1.png","http://example.com/img/day/day1/%E5%BF%AB%E9%80%9F2.gif","http://example.com/img/day/day1/%E5%BF%AB%E9%80%9F3.gif"],"datePublished":"2021-12-08T07:30:40.000Z","dateModified":"2022-07-23T14:12:02.892Z","author":{"@type":"Person","name":"YiSunYiMao"},"publisher":{"@type":"Organization","name":"一榫一卯-YiSunYiMao","logo":{"@type":"ImageObject","url":"http://example.com/img/yisunyimao.svg"}},"description":"数据结构、C语言、python"}</script><link rel="canonical" href="http://example.com/2021/12/8/%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/yisunyimao.svg" alt="一榫一卯-YiSunYiMao" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home主页</a><a class="navbar-item" href="/archives">Archives归档</a><a class="navbar-item" href="/categories">Categories分类</a><a class="navbar-item" href="/tags">Tags标签</a><a class="navbar-item" href="/friend">Friend友链</a><a class="navbar-item" href="/navigation">Navigation导航</a><a class="navbar-item" href="/about">About关于</a><a class="navbar-item" href="/message">Message留言</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="C++ 中文版开源书" href="https://changkun.de/modern-cpp/zh-cn/00-preface/index.html"><i class="fa fa-link"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="研招网" href="https://yz.chsi.com.cn/"><i class="fa fa-share-alt"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="en-wiki" href="https://en.jinzhao.wiki/wiki/Main_Page"><i class="fab fa-wikipedia-w"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="大英百科全书" href="https://www.britannica.com/"><i class="fa fa-arrows-alt"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>排序方法合集</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2021-12-08T07:30:40.000Z" title="2021-12-08T07:30:40.000Z">2021-12-08</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2022-07-23T14:12:02.892Z" title="2022-07-23T14:12:02.892Z">2022-07-23</time></span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/">个人生活</a><span> / </span><a class="link-muted" href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</a><span> / </span><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/">计算机专业</a></span><span class="level-item">24 分钟读完 (大约3542个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><p>数据结构、C语言、python</p>
<span id="more"></span>
<hr>
<p><img src="/img/day/day1/%E6%AF%94%E8%BE%83.png"></p>
<hr>
<h1 id="※冒泡排序※"><a href="#※冒泡排序※" class="headerlink" title="※冒泡排序※"></a><strong>※冒泡排序※</strong></h1><p><strong>分析：</strong><br><img src="/img/day/day1/%E5%86%92%E6%B3%A11.png"><br>那么我们需要进行n-1次冒泡过程，每次对应的比较次数如下图所示：</p>
<table>
<thead>
<tr>
<th>Pass</th>
<th>Comparisons</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>n-1</td>
</tr>
<tr>
<td>2</td>
<td>n-2</td>
</tr>
<tr>
<td>3</td>
<td>n-3</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>n-1</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="/img/day/day1/%E5%86%92%E6%B3%A12.gif"><br>蓝色代表待比较的值<br>绿色代表两个值比较并判断是否交换<br>橙色代表比较一轮后确定位置的元素，该元素不再参与比较</p>
<h2 id="python3"><a href="#python3" class="headerlink" title="#python3"></a>#python3</h2><pre><code>从小到大，只需将“if a[j]&gt;a[j+1]:”改为“if a[j]&lt;a[j+1]:”即可变成从大到小。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def bubble_sort(a):			#冒泡排序</span><br><span class="line">    for i in range(len(a)-1):			#i表示第i+1轮冒泡</span><br><span class="line">        for j in range(len(a)-1):		#j表示第j+1个元素与下一个元素比较</span><br><span class="line">            if a[j]&gt;a[j+1]:				#从小到大</span><br><span class="line">                a[j],a[j+1]=a[j+1],a[j]</span><br><span class="line">    return a</span><br><span class="line"></span><br><span class="line">#注意range(len(a)-1)即：a[0]、a[1]、...、a[len(a)-2]</span><br></pre></td></tr></table></figure>


<h2 id="C语言"><a href="#C语言" class="headerlink" title="#C语言"></a>#C语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void bubble_sort(int a[],int len)	#len为数组元素的个数</span><br><span class="line">&#123;</span><br><span class="line">    int t;		#中间变量t是作为交换的中间介质</span><br><span class="line">    for(int i=0;i&lt;len-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=len-1;j&gt;i;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[j+1]&lt;a[j])		#从小到大</span><br><span class="line">            &#123;</span><br><span class="line">                t=a[j];</span><br><span class="line">                a[j]=a[j+1];</span><br><span class="line">                a[j+1]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;第%d遍：&quot;,i+1);</span><br><span class="line">        for(int j=0;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%2d &quot;,a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="※选择排序※"><a href="#※选择排序※" class="headerlink" title="※选择排序※"></a><strong>※选择排序※</strong></h1><p><strong>分析：</strong><br><img src="/img/day/day1/%E9%80%89%E6%8B%A92.gif"><br>在未排序序列中找到最大（小）元素，存放在排序序列的起始位置<br>再从剩余未排序的元素中继续寻找最大（小）元素，然后放到已排序序列的末尾<br>以此类推，直到所有的元素均排序完毕<br><img src="/img/day/day1/%E9%80%89%E6%8B%A91.png"><br>选择排序的主要优点与数据移动有关，如果某个元素位于正确的位置上，则它不会被移动<br>选择排序每次交换一对元素，它们当中至少有一个将被移动其最终位置上<br>因此对n个元素的表进行排序总共进行至多n-1次交换</p>
<h2 id="python3-1"><a href="#python3-1" class="headerlink" title="#python3"></a>#python3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def select_sort(a):</span><br><span class="line">    for i in range(len(a)):</span><br><span class="line">        for j in range(i+1,len(a)):</span><br><span class="line">            if a[i] &gt; a[j]:</span><br><span class="line">                a[j],a[i]=a[i],a[j]	#找出最小元素，赋给a[i],最后序列升序，即从小到大</span><br><span class="line">    return a</span><br></pre></td></tr></table></figure>


<h2 id="C语言-1"><a href="#C语言-1" class="headerlink" title="#C语言"></a>#C语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void choice(int *a,int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,t;</span><br><span class="line">    for(i=0;i&lt;len-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=i+1;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[i]&gt;a[j])</span><br><span class="line">            &#123;t=a[i];a[i]=a[j];a[j]=t;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#找出最小元素，赋给a[i],最后序列升序，即从小到大</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="※直接插入排序※"><a href="#※直接插入排序※" class="headerlink" title="※直接插入排序※"></a><strong>※直接插入排序※</strong></h1><p><strong>分析：</strong><br><img src="/img/day/day1/%E6%8F%92%E5%85%A52.gif"><br>打扑克摸牌时，从牌堆里一张一张摸起来的牌都是乱序的，我们会把摸起来的牌插入到左手中合适的位置，让左手中的牌变得时刻有序<br><img src="/img/day/day1/%E6%8F%92%E5%85%A51.png"><br>那如果我们不是从牌堆里摸牌，而是左手里面初始化就是一堆乱牌呢？<br>一样的道理，我们把牌往手的右边挪一挪，把手的左边空出一点位置来，然后在乱牌中抽一张出来，插入到左边，再抽一张出来，插入到左边，再抽一张，插入到左边，每次插入都插入到左边合适的位置，时刻保持左边的牌是有序的，直到右边的牌抽完，则排序完毕</p>
<h2 id="python3-2"><a href="#python3-2" class="headerlink" title="#python3"></a>#python3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#从第二个位置开始遍历，与它前面的元素相比较，如果比前面元素小就交换位置</span><br><span class="line">def insert_sort(a):</span><br><span class="line">    for i in range(1, len(a)):	#从第i个元素开始向前比较，如果小于前一个元素，交换位置</span><br><span class="line">        for j in range(i,0,-1):</span><br><span class="line">            if a[j]&lt;a[j-1]:</span><br><span class="line">                a[j],a[j-1]=a[j-1],a[j]</span><br><span class="line">    return a</span><br></pre></td></tr></table></figure>

<h2 id="C语言-2"><a href="#C语言-2" class="headerlink" title="#C语言"></a>#C语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#从小到大</span><br><span class="line">void insert_sort(int *k,int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,t;</span><br><span class="line">    for(i=1;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t=k[i];	#将要比较的值先绶存起来留出一个空位，方便移动</span><br><span class="line">        j=i-1;</span><br><span class="line">        while(j&gt;=0&amp;&amp;k[j]&gt;t)	#比较直到出现比t大的值，或向前找到头</span><br><span class="line">        &#123;</span><br><span class="line">            k[j+1]=k[j];	#将前面的值往后移</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        k[j+1]=t;	#插在a[j]的后面</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="※折半插入排序※"><a href="#※折半插入排序※" class="headerlink" title="※折半插入排序※"></a><strong>※折半插入排序※</strong></h1><p><strong>分析：</strong><br>折半插入排序利用二分法的思想，在一个有序的序列中，找到新元素在该序列中的位置，然后插入<br><img src="/img/day/day1/%E6%8A%98%E5%8D%8A1.png"><br>如图所示，共有n个元素，前i个元素已经是有序序列，现在要将第i个元素插入其中<br>折半插入排序需要做两步工作：找到待插入元素的位置、插入。<br><img src="/img/day/day1/%E6%8A%98%E5%8D%8A2.png"><br>首先要定义两个指针(不是语法里面的指针，是下标的意思)low和high用于寻找a[i]的插入位置，low指向a[0]，high指向a[i-1]，中点mid=(low+high)/2</p>
<p>二分法的思想是比较a[i]与a[mid]的大小<br>若a[i]&gt;a[mid]，说明a[i]的位置应该在mid至high之间，将区间[low,high]缩短为[mid+1,high]，令指针low=mid+1<br>若a[i]&lt;=a[mid]，说明a[i]的位置应该在low至mid之间，将区间压缩为[low,mid-1]，令指针high=mid-1<br>每次折半之后，a[i]的位置应该在[low,high]之间，如此循环，low与high渐渐靠近，直到low&gt;high跳出循环，a[i]的位置找到，low即为a[i]应该放置的位置<br>找到a[i]的位置之后进行插入，先将a[low]至a[i-1]这些元素向后平移一个元素的位置，然后将a[i]放到low位置</p>
<pre><code>如果记录用链表结构存储，用直接插入排序无需移动元素，时间效率更高
但是链表结构无法进行折半查找
</code></pre>
<h2 id="python3-3"><a href="#python3-3" class="headerlink" title="#python3"></a>#python3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#从小到大</span><br><span class="line">def half_insert_sort(a):</span><br><span class="line">    for index in range(1,len(a)):</span><br><span class="line">        current_value=a[index]</span><br><span class="line">        position=index</span><br><span class="line">        low=0</span><br><span class="line">        high=index-1</span><br><span class="line">        while low&lt;=high:</span><br><span class="line">            mid = (low + high) // 2</span><br><span class="line">            if a[mid]&gt;current_value:</span><br><span class="line">                high=mid - 1</span><br><span class="line">            else:</span><br><span class="line">                low=mid + 1</span><br><span class="line">        while position&gt;low:</span><br><span class="line">            a[position]=a[position-1]</span><br><span class="line">            position=position-1</span><br><span class="line">        a[position]=current_value</span><br></pre></td></tr></table></figure>

<h2 id="C语言-3"><a href="#C语言-3" class="headerlink" title="#C语言"></a>#C语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#从小到大</span><br><span class="line">void half_insert_sort(a)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,low,high,mid;</span><br><span class="line">    for(i=2;i&lt;=len(a);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[0]=a[i];</span><br><span class="line">        low=1;</span><br><span class="line">        high=i-1;	#设置折半查找的范围，从1到i-1,A[0]用来暂存元素</span><br><span class="line">        while(low&lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(low+high)/2;</span><br><span class="line">            if(a[mid].key&gt;a[0].key) </span><br><span class="line">            high=mid-1;	#查找左半子表</span><br><span class="line">            else </span><br><span class="line">            low=mid+1;	#查找右半子表</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(j=i-1;j&gt;=high+1;--j)</span><br><span class="line">                a[j+1]=a[j];	#统一向后移动元素，空出插入位置</span><br><span class="line">        a[high+1]=a[0];	#插入操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="※希尔排序※"><a href="#※希尔排序※" class="headerlink" title="※希尔排序※"></a><strong>※希尔排序※</strong></h1><p><strong>分析：</strong><br>是直接插入排序算法的一种更高效的改进版本，但希尔排序是非稳定排序算法<br>交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序<br>我们选择增量gap=len//2，缩小增量以gap=gap//2的方式，用序列 {n/2,(n/2)/2…1} 来表示<br><img src="/img/day/day1/%E5%B8%8C%E5%B0%941.png"><br>初始增量第一趟gap=len/2=4<br><img src="/img/day/day1/%E5%B8%8C%E5%B0%942.png"><br>第二趟，增量缩小为gap=gap//2=4//2=2<br><img src="/img/day/day1/%E5%B8%8C%E5%B0%943.png"><br>第三趟，增量缩小为 1,得到最终排序结果</p>
<h2 id="python3-4"><a href="#python3-4" class="headerlink" title="#python3"></a>#python3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def shell_sort(a):</span><br><span class="line">    gap=len(a)//2</span><br><span class="line">    while gap&gt;=1:	#j是需要比较的次数</span><br><span class="line">        for j in range(gap,len(a)):	#i是需要控制的索引</span><br><span class="line">            i=j 	#比较的逻辑和控制i的变换的逻辑</span><br><span class="line">            while(i-gap)&gt;=0:</span><br><span class="line">                if a[i]&lt;a[i-gap]:	#交换</span><br><span class="line">                    a[i],a[i-gap]=a[i-gap],a[i]	#修改i</span><br><span class="line">                    i-=gap</span><br><span class="line">                else:</span><br><span class="line">                    break	#控制间隙的变化</span><br><span class="line">        gap//=2</span><br></pre></td></tr></table></figure>

<h2 id="C语言-4"><a href="#C语言-4" class="headerlink" title="#C语言"></a>#C语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void shellSort(int *a, int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,k,t,gap;</span><br><span class="line">    for (gap=len/2;gap&gt;0;gap/=2)	#步长初始化为数组长度的一半，每次遍历后步长减半</span><br><span class="line">    &#123;</span><br><span class="line">    	for (i=0;i&lt;gap;++i)		#变量i为每次分组的第一个元素下标 </span><br><span class="line">    	&#123;</span><br><span class="line">	        for (j=i+gap;j&lt;len;j+=gap)	#对步长为gap的元素进行直插排序，当gap为1时，就是直插排序</span><br><span class="line">	        &#123;</span><br><span class="line">	            t=a[j];	#备份a[j]的值</span><br><span class="line">	            k=j-gap;	#j初始化为i的前一个元素（与i相差gap长度）</span><br><span class="line">	            while(k&gt;=0&amp;&amp;a[k]&gt;t) </span><br><span class="line">	            &#123;</span><br><span class="line">	                a[k+gap]=a[k];	#将在a[i]前且比tmp的值大的元素向后移动一位</span><br><span class="line">	                k-=gap;</span><br><span class="line">	            &#125;</span><br><span class="line">	            a[k+gap]=t; </span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="※堆排序※"><a href="#※堆排序※" class="headerlink" title="※堆排序※"></a><strong>※堆排序※</strong></h1><p><strong>分析：</strong><br>堆（Heap）：（二叉）堆数据结构是一个数组对象，可以视为一棵完全二叉树<br>堆排序是一种选择排序，也是一种不稳定排序<br><img src="/img/day/day1/%E5%A0%861.png"><br>大顶堆（即大根堆）：每个结点的值都大于或等于其左右孩子结点的值，升序序列<br>小顶堆（即小根堆）：每个结点的值都小于或等于其左右孩子结点的值，降序序列</p>
<p>设有一个无序序列 {1,3,4,5,2,6,9,7,8,0}进行堆排序，进行堆排序：</p>
<pre><code>（这里面的每个元素没有按照一定的规则排序，所以就叫无序）
</code></pre>
<p>1.先对无序序列进行堆的初始化，只是找出了第一个是最大的值（最大堆），或者最小的值（最小堆），这也就是为什么堆排序是选择排序，它都是每次找到最大或者最小<br><img src="/img/day/day1/%E5%A0%862.png"><br>上面就完成了堆的初始化，初始化后的有序序列{9，8，6，7，2，1，4，3，5，0}</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>列表元素</td>
<td>9</td>
<td>8</td>
<td>6</td>
<td>7</td>
<td>2</td>
<td>1</td>
<td>4</td>
<td>3</td>
<td>5</td>
<td>0</td>
</tr>
<tr>
<td>序列下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>2.堆排序<br>①把根节点和末尾结点交换，并且弹出末尾点<br>所以弹出9，这个9就存储进了数组里，数组第一个值（最大值）就排序好了<br>②接下来按照初始化的方法，继续排序<br><img src="/img/day/day1/%E5%A0%863.png"><br>重复①②，一直到堆为空<br>至此，每次弹出去的都是最大值，9，8，7，6···<br>整个数组堆排序完成，得到的序列</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>列表元素</td>
<td>9</td>
<td>8</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>序列下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="python3-5"><a href="#python3-5" class="headerlink" title="#python3"></a>#python3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def MAX_Heapify(heap,HeapSize,root):	#在堆中做结构调整使得父节点的值大于子节点</span><br><span class="line"></span><br><span class="line">    left = 2*root + 1</span><br><span class="line">    right = left + 1</span><br><span class="line">    larger = root</span><br><span class="line">    if left &lt; HeapSize and heap[larger] &lt; heap[left]:</span><br><span class="line">        larger = left</span><br><span class="line">    if right &lt; HeapSize and heap[larger] &lt; heap[right]:</span><br><span class="line">        larger = right</span><br><span class="line">    if larger != root:	#如果做了堆调整则larger的值等于左节点或者右节点的，这个时候做对调值操作</span><br><span class="line">        heap[larger],heap[root] = heap[root],heap[larger]</span><br><span class="line">        MAX_Heapify(heap, HeapSize, larger)</span><br><span class="line"></span><br><span class="line">def Build_MAX_Heap(heap):	#构造一个堆，将堆中所有数据重新排序</span><br><span class="line">    HeapSize = len(heap)	#将堆的长度当独拿出来方便</span><br><span class="line">    for i in xrange((HeapSize -2)//2,-1,-1):	#从后往前出数</span><br><span class="line">        MAX_Heapify(heap,HeapSize,i)</span><br><span class="line"></span><br><span class="line">def HeapSort(heap):	#将根节点取出与最后一位做对调，对前面len-1个节点继续进行对调整过程。</span><br><span class="line">    Build_MAX_Heap(heap)</span><br><span class="line">    for i in range(len(heap)-1,-1,-1):</span><br><span class="line">        heap[0],heap[i] = heap[i],heap[0]</span><br><span class="line">        MAX_Heapify(heap, i, 0)</span><br><span class="line">    return heap</span><br></pre></td></tr></table></figure>

<h2 id="C语言-5"><a href="#C语言-5" class="headerlink" title="#C语言"></a>#C语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">void swap(int num[],int i,int j)	#交换结点</span><br><span class="line">&#123;</span><br><span class="line">	int temp;</span><br><span class="line">	temp=num[i];</span><br><span class="line">	num[i]=num[j];</span><br><span class="line">	num[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Heapify(int num[],int len,int k)	#最大堆调整</span><br><span class="line">&#123;</span><br><span class="line">	if(k&lt;len)</span><br><span class="line">	&#123;</span><br><span class="line">		int max=k;	#根结点</span><br><span class="line">		int s1=2*k+1;	#左子节点</span><br><span class="line">		int s2=2*k+2;	#右子结点</span><br><span class="line">	#找出最大结点</span><br><span class="line">		if(num[s1]&gt;num[max]&amp;&amp;s1&lt;len)</span><br><span class="line">			max=s1;</span><br><span class="line">		if(num[s2]&gt;num[max]&amp;&amp;s2&lt;len)</span><br><span class="line">			max=s2;</span><br><span class="line">	#交换最大子节点到根结点并做递归</span><br><span class="line">		if(max!=k)</span><br><span class="line">		&#123;</span><br><span class="line">			swap(num,max,k);</span><br><span class="line">			Heapify(num,len,max);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CreateHeap(int num[],int len)	#创建最大堆</span><br><span class="line">&#123;</span><br><span class="line">	int last=len-1;		#最后一个子结点位置</span><br><span class="line">	int parent=(last-1)/2;	#最后一个子结点的父结点</span><br><span class="line">	for(int i=parent;i&gt;=0;i--)	</span><br><span class="line">	&#123;</span><br><span class="line">		Heapify(num,len,i);		#从最后一个父结点开始做最大堆调整</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HeapSort(int num[],int len)	#堆排序</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	CreateHeap(num,len);	#创建最大堆</span><br><span class="line">	for(int i=len-1;i&gt;=0;i--)	#依次将最大堆的根结点（最大值）取出</span><br><span class="line">	&#123;	#将最大堆的根（最大值）换到最后</span><br><span class="line">		swap(num,i,0);	#除去最大值,对交换后的二叉树做最大堆调整，使二叉树根结点始终为最大值	</span><br><span class="line">		Heapify(num,i,0);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="※归并排序※"><a href="#※归并排序※" class="headerlink" title="※归并排序※"></a><strong>※归并排序※</strong></h1><p><strong>分析：</strong><br>归并排序（Merge Sort）指的是利用分治和递归的思想，对一个乱序的数列进行排序<br>分：指的是将一个乱序数列不断进行二分，得到许多短的序列<br>治：指的是将这些短序列进行两两合并，然后将合并的结果作为新的序列，再与其他序列进行合并，最终得到一个新的序列<br>因此，归并排序具体包括两个步骤：分散、和并<br><img src="/img/day/day1/%E5%BD%92%E5%B9%B62.png"><br>在合并的起始阶段，每个序列就是一个元素，自然是有序的，然后进行正确的合并操作之后，输出的也是有序的<br>正确的合并操作是怎么操作了。比如有两个有序的数列L1和L2，想要对其进行合并，可以：<br>1、定义两个指针，分别指向两个数列的第一个元素；定义新的空数列，作为结果<br>2、依次取出指针值，比较大小，将较小值追加到新数列，同时将较小值的指针往后移动一位<br>3、如果其中一个指针到头了，那么将另一个指针剩下的数列直接追加到结果数列即可<br>4、直至两个指针都指到了最后一位<br>这样，得到的结果数列便是有序数列<br><img src="/img/day/day1/%E5%BD%92%E5%B9%B61.gif"></p>
<h2 id="python3-6"><a href="#python3-6" class="headerlink" title="#python3"></a>#python3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def merge_sort(a):	#对数组a进行归并排序</span><br><span class="line">    if len(a)&lt;=1:	#递归结束条件</span><br><span class="line">        return a</span><br><span class="line">    middle=len(a)//2	    #分治进行递归</span><br><span class="line">    left=merge_sort(a[:middle])</span><br><span class="line">    right=merge_sort(a[middle:])</span><br><span class="line">    #将两个有序数组进行合并</span><br><span class="line">    result=[]</span><br><span class="line">    i=j=0</span><br><span class="line">    while i&lt;len(left) and j&lt;len(right):</span><br><span class="line">    #将较小值放入到result中</span><br><span class="line">        if left[i]&lt;right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i+=1</span><br><span class="line">        else:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j+=1</span><br><span class="line">    #将未被扫描到的直接追加到result后面</span><br><span class="line">    if i==len(left):</span><br><span class="line">        result.extend(right[j:])</span><br><span class="line">    else:</span><br><span class="line">        result.extend(left[i:])</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">alex=[25,49,62,12,3,10,0,15,54,53]</span><br><span class="line">merge_sort(alex)</span><br><span class="line">print(alex)</span><br><span class="line">b=merge_sort(alex)</span><br><span class="line">print(b)</span><br><span class="line">print(merge_sort(alex))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果如图所示<br><img src="/img/day/day1/%E5%BD%92%E5%B9%B63.png"></p>
<h2 id="C语言-6"><a href="#C语言-6" class="headerlink" title="#C语言"></a>#C语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#归并排序中的合并算法</span><br><span class="line">void Merge(int array[],int left,int m,int right)</span><br><span class="line">&#123;</span><br><span class="line">    int aux[Max_] = &#123;0&#125;;	#临时数组（若不使用临时数组，将两个有序数组合并为一个有序数组比较麻烦）</span><br><span class="line">    int i;	#第一个数组索引</span><br><span class="line">    int j;	#第二个数组索引</span><br><span class="line">    int k;	#临时数组索引</span><br><span class="line">    for (i=left,j=m+1,k=0;k&lt;=right-left;k++)	#分别将 i, j, k 指向各自数组的首部</span><br><span class="line">    &#123;	#若i到达第一个数组的尾部，将第二个数组余下元素复制到 临时数组中</span><br><span class="line">        if(i==m+1)</span><br><span class="line">        &#123;aux[k]=array[j++];continue;&#125;</span><br><span class="line">        #若j到达第二个数组的尾部，将第一个数组余下元素复制到临时数组中</span><br><span class="line">        if(j==right+1)</span><br><span class="line">        &#123;aux[k]=array[i++];continue;&#125;</span><br><span class="line">        #如果第一个数组的当前元素比第二个数组的当前元素小，将第一个数组的当前元素复制到临时数组中</span><br><span class="line">        if (array[i]&lt;array[j])</span><br><span class="line">        &#123;aux[k]=array[i++];&#125;</span><br><span class="line">        #如果第二个数组的当前元素比第一个数组的当前元素小，将第二个数组的当前元素复制到临时数组中</span><br><span class="line">        else</span><br><span class="line">        &#123;aux[k] = array[j++];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #将有序的临时数组元素刷回被排序的数组array中，</span><br><span class="line">    #i=left，被排序的数组array的起始位置</span><br><span class="line">    #j=0，临时数组的起始位置</span><br><span class="line">    for(i=left,j=0;i&lt;=right;i++,j++)</span><br><span class="line">    &#123;array[i]=aux[j];&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#归并排序</span><br><span class="line">void MergeSort(int array[],int start,int end)</span><br><span class="line">&#123;</span><br><span class="line">    if (start&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        int i;</span><br><span class="line">        i=(end+start)/2;</span><br><span class="line">        #对前半部分进行排序</span><br><span class="line">        MergeSort(array,start,i);</span><br><span class="line">        #对后半部分进行排序</span><br><span class="line">        MergeSort(array,i+1,end);</span><br><span class="line">        #合并前后两部分</span><br><span class="line">        Merge(array,start,i,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="※快速排序※"><a href="#※快速排序※" class="headerlink" title="※快速排序※"></a><strong>※快速排序※</strong></h1><p><strong>分析：</strong><br><img src="/img/day/day1/%E5%BF%AB%E9%80%9F1.png"><br>任取待排序元素序列中的某元素作为基准值（pivot），按照该排序码将待排序集合分割成两子序列<br>左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值（单趟排序）<br>然后左右子序列重复该过程（递归），直到所有元素都排列在相应位置上为止</p>
<p>①左右哨兵法<br><img src="/img/day/day1/%E5%BF%AB%E9%80%9F2.gif"><br>以最左端为基准值举例：</p>
<pre><code>黄色为基准值
浅蓝色为等待与基准值比较的值
红色为为正在于基准值比较的值
紫色为经过比较判断后的大于目前基准值的值
绿色为经过比较判断后的小于目前基准值的值
橙色为已拍好顺序的值
</code></pre>
<p>②挖坑法<br><img src="/img/day/day1/%E5%BF%AB%E9%80%9F3.gif"><br>选择最右边的数字6作为基准值（pivot）：</p>
<pre><code>选取好pivot后，在操作数列中选择最左边的数字标记为左标记，最右边的数字标记为右标记
将左边的标记L向右移动，当左标记L达到超过pivot的数字时，停止移动
在这里，8&gt;6 ,所以停止移动，然后将右边的标记向左移动
当右标记R达到小于pivot的数字时，停止移动
在这里，4&gt;6 ,所以停止移动
当左右标记停止时，更改标记的数字
因此，左标记的作用是找到一个大于pivot的数字，右标记的作用是找到一个小于pivot的数字
通过交换数字，可以在数列的左边收集小于pivot的数字集合，右边收集大于pivot的数字集合
交换之后，继续移动左标记
在这里，9&gt;6，所以停止移动，然后将右边的标记向左移动
当右标记碰撞到左标记时也停止移动
当左右侧的标记停止并且都在同一个位置时，将这个数字和pivot的数字交换，这就完成了第一次操作
小于6的都在6的左侧，大于6的都在6的右侧
然后递归对这分成的两部分都执行同样的操作，完成排序
</code></pre>
<h2 id="python3-7"><a href="#python3-7" class="headerlink" title="#python3"></a>#python3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#左右哨兵法</span><br><span class="line">def quick_sort(a):</span><br><span class="line">    if len(a) &lt;= 1:</span><br><span class="line">        return a</span><br><span class="line">    #左边数组</span><br><span class="line">    left = []</span><br><span class="line">    #右边数组</span><br><span class="line">    right = []</span><br><span class="line">    #基准数</span><br><span class="line">    pivot = a.pop()</span><br><span class="line">    #对原数组进行划分</span><br><span class="line">    for x in a:</span><br><span class="line">        if x &lt; pivot:</span><br><span class="line">            left.append(x)</span><br><span class="line">        else:</span><br><span class="line">            right.append(x)</span><br><span class="line">    #递归调用</span><br><span class="line">    return quick_sort(left) + [pivot] + quick_sort(right)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#挖坑法</span><br><span class="line">def quick_sort(data, left, right):</span><br><span class="line">    if left &lt; right:</span><br><span class="line">        mid = partition(data, left, right)</span><br><span class="line">        quick_sort(data, left, mid - 1)</span><br><span class="line">        quick_sort(data, mid + 1, right)</span><br><span class="line">#此函数执行结束后，左边的数一定不大于tmp，右边的数一定不小于tmp</span><br><span class="line">def partition(data, left, right):</span><br><span class="line">    tmp = data[left]</span><br><span class="line">    while left &lt; right:</span><br><span class="line">        while left &lt; right and data[right] &gt;= tmp:</span><br><span class="line">            right -= 1</span><br><span class="line">        data[left] = data[right]</span><br><span class="line">        while left &lt; right and data[left] &lt;= tmp:</span><br><span class="line">            left += 1</span><br><span class="line">        data[right] = data[left]</span><br><span class="line">    data[left] = tmp</span><br><span class="line">    return left</span><br><span class="line"></span><br><span class="line">quick_sort(lst, 0, len(lst) - 1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="C语言-7"><a href="#C语言-7" class="headerlink" title="#C语言"></a>#C语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#左右哨兵法</span><br><span class="line">int PartSort1(int* a, int left, int right)</span><br><span class="line">&#123;	#下面两行代码为优化，后文会讲到</span><br><span class="line">    int midIndex = GetMidIndex(a, left, right);</span><br><span class="line">    Swap(&amp;a[left], &amp;a[midIndex]);</span><br><span class="line">    int key_i = left;</span><br><span class="line">    while (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        #从右边开始寻找比a[key]小的元素</span><br><span class="line">        #注意先判断left &lt; right，否则可能越界</span><br><span class="line">        #注意a[right] &gt;= a[key_i]的等号，否则可能死循环</span><br><span class="line">        while (left &lt; right &amp;&amp; a[right] &gt;= a[key_i])</span><br><span class="line">            right--;</span><br><span class="line">        #再从左边开始寻找比a[key]大的元素</span><br><span class="line">        while (left &lt; right &amp;&amp; a[left] &lt;= a[key_i])</span><br><span class="line">            left++;</span><br><span class="line">        Swap(&amp;a[left], &amp;a[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    #left == right</span><br><span class="line">    int meet_i = left;</span><br><span class="line">    Swap(&amp;a[key_i], &amp;a[meet_i]);</span><br><span class="line">    return meet_i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void QuickSort(int* a, int left, int right)</span><br><span class="line">&#123;	#[left,right]区间内只剩一个或0个元素，即有序，不需要排</span><br><span class="line">    if (left &gt;= right)</span><br><span class="line">        return;</span><br><span class="line">    int mid = PartSort1(a, left, right);</span><br><span class="line">    #mid位置已经是最终的位置，对[left,mid-1]和[mid+1,right]排序</span><br><span class="line">    QuickSort(a, left, mid - 1);</span><br><span class="line">    QuickSort(a, mid + 1, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#挖坑法</span><br><span class="line">void QuickSort(int array[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    int i = low; </span><br><span class="line">    int j = high;</span><br><span class="line">    if(i &gt;= j) </span><br><span class="line">    &#123;return;&#125;</span><br><span class="line">    int temp = array[low];</span><br><span class="line">    while(i != j) </span><br><span class="line">    &#123;</span><br><span class="line">        while(array[j] &gt;= temp &amp;&amp; i &lt; j) </span><br><span class="line">        &#123;j--;&#125;</span><br><span class="line">	while(array[i] &lt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">	&#123;i++;&#125;</span><br><span class="line">	if(i &lt; j) </span><br><span class="line">	&#123;swap(array[i], array[j]);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #将基准temp放于自己的位置，（第i个位置）</span><br><span class="line">    swap(array[low], array[i]);</span><br><span class="line">    QuickSort(array, low, i - 1);</span><br><span class="line">    QuickSort(array, i + 1, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="article-licensing box"><div class="licensing-title"><p>排序方法合集</p><p><a href="http://example.com/2021/12/8/排序方法合集/">http://example.com/2021/12/8/排序方法合集/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>YiSunYiMao</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-12-08</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-07-23</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="icon fab fa-creative-commons"></i><i class="icon fab fa-creative-commons-by"></i><i class="icon fab fa-creative-commons-nc"></i><i class="icon fab fa-creative-commons-sa"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/python/">python</a><a class="link-muted mr-2" rel="tag" href="/tags/C/">C</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/%E6%94%B6%E6%AC%BE/alipay.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/%E6%94%B6%E6%AC%BE/wechat.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/12/14/seer%E6%A1%A3%E6%A1%88%E5%9B%9E%E5%BF%86%E5%BD%95-090904/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">SEER档案回忆录-090904</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/11/6/seer%E6%A1%A3%E6%A1%88%E5%9B%9E%E5%BF%86%E5%BD%95-090828/"><span class="level-item">SEER档案回忆录-090828</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "c24fed588f1ce86a145fe686da7dd0d4",
            repo: "YiSunYiMao.github.io",
            owner: "YiSunYiMao",
            clientID: "5f067cbf04300137dbb9",
            clientSecret: "0c49ad28b710b6f327c9052db19b5e848e2cb1f4",
            admin: ["YiSunYiMao"],
            createIssueManually: false,
            distractionFreeMode: true,
            perPage: 25,
            pagerDirection: "first",
            proxy: "https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token",
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-05-14T14:18:01.000Z">2022-05-14</time></p><p class="title"><a href="/2022/5/14/seer%E6%A1%A3%E6%A1%88%E5%9B%9E%E5%BF%86%E5%BD%95-100108/">SEER档案回忆录-100108</a></p><p class="categories"><a href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/">个人生活</a> / <a href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/%E6%A2%A6%E5%9B%9E%E7%AB%A5%E5%B9%B4/">梦回童年</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-06T08:28:14.000Z">2022-04-06</time></p><p class="title"><a href="/2022/4/6/seer%E6%A1%A3%E6%A1%88%E5%9B%9E%E5%BF%86%E5%BD%95-091106/">SEER档案回忆录-091106</a></p><p class="categories"><a href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/">个人生活</a> / <a href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/%E6%A2%A6%E5%9B%9E%E7%AB%A5%E5%B9%B4/">梦回童年</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-12T11:39:31.000Z">2022-02-12</time></p><p class="title"><a href="/2022/2/12/seer%E6%A1%A3%E6%A1%88%E5%9B%9E%E5%BF%86%E5%BD%95-091204/">SEER档案回忆录-091204</a></p><p class="categories"><a href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/">个人生活</a> / <a href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/%E6%A2%A6%E5%9B%9E%E7%AB%A5%E5%B9%B4/">梦回童年</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-02T09:37:54.000Z">2022-01-02</time></p><p class="title"><a href="/2022/1/2/seer%E6%A1%A3%E6%A1%88%E5%9B%9E%E5%BF%86%E5%BD%95-091231/">SEER档案回忆录-091231</a></p><p class="categories"><a href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/">个人生活</a> / <a href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/%E6%A2%A6%E5%9B%9E%E7%AB%A5%E5%B9%B4/">梦回童年</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-14T13:26:55.000Z">2021-12-14</time></p><p class="title"><a href="/2021/12/14/seer%E6%A1%A3%E6%A1%88%E5%9B%9E%E5%BF%86%E5%BD%95-090904/">SEER档案回忆录-090904</a></p><p class="categories"><a href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/">个人生活</a> / <a href="/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/%E6%A2%A6%E5%9B%9E%E7%AB%A5%E5%B9%B4/">梦回童年</a></p></div></article></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#※冒泡排序※"><span class="level-left"><span class="level-item">1</span><span class="level-item">※冒泡排序※</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#python3"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">#python3</span></span></a></li><li><a class="level is-mobile" href="#C语言"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">#C语言</span></span></a></li></ul></li><li><a class="level is-mobile" href="#※选择排序※"><span class="level-left"><span class="level-item">2</span><span class="level-item">※选择排序※</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#python3-1"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">#python3</span></span></a></li><li><a class="level is-mobile" href="#C语言-1"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">#C语言</span></span></a></li></ul></li><li><a class="level is-mobile" href="#※直接插入排序※"><span class="level-left"><span class="level-item">3</span><span class="level-item">※直接插入排序※</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#python3-2"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">#python3</span></span></a></li><li><a class="level is-mobile" href="#C语言-2"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">#C语言</span></span></a></li></ul></li><li><a class="level is-mobile" href="#※折半插入排序※"><span class="level-left"><span class="level-item">4</span><span class="level-item">※折半插入排序※</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#python3-3"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">#python3</span></span></a></li><li><a class="level is-mobile" href="#C语言-3"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">#C语言</span></span></a></li></ul></li><li><a class="level is-mobile" href="#※希尔排序※"><span class="level-left"><span class="level-item">5</span><span class="level-item">※希尔排序※</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#python3-4"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">#python3</span></span></a></li><li><a class="level is-mobile" href="#C语言-4"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">#C语言</span></span></a></li></ul></li><li><a class="level is-mobile" href="#※堆排序※"><span class="level-left"><span class="level-item">6</span><span class="level-item">※堆排序※</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#python3-5"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">#python3</span></span></a></li><li><a class="level is-mobile" href="#C语言-5"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">#C语言</span></span></a></li></ul></li><li><a class="level is-mobile" href="#※归并排序※"><span class="level-left"><span class="level-item">7</span><span class="level-item">※归并排序※</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#python3-6"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">#python3</span></span></a></li><li><a class="level is-mobile" href="#C语言-6"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">#C语言</span></span></a></li></ul></li><li><a class="level is-mobile" href="#※快速排序※"><span class="level-left"><span class="level-item">8</span><span class="level-item">※快速排序※</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#python3-7"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">#python3</span></span></a></li><li><a class="level is-mobile" href="#C语言-7"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">#C语言</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/yisunyimao.svg" alt="一榫一卯-YiSunYiMao" height="28"></a><p class="is-size-7"><span>&copy; 2022 YiSunYiMao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> <i class="fab fa-creative-commons-nc"></i> <i class="fab fa-creative-commons-sa"></i> </a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'folded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>